# Задание 1.
# Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых трех уроков.Примечание.
# Идеальным решением будет:
# ● выбрать хорошую задачу, которую имеет смысл оценивать,
# ● написать 3 варианта кода (один у вас уже есть),
# ● проанализировать 3 варианта и выбрать оптимальный,
# ● результаты анализа вставить в виде комментариев в файл с кодом (не забудьте указать, для каких N вы проводили замеры),
# ● написать общий вывод: какой из трёх вариантов лучше и почему.

# Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран. Например, если введено число 3486, надо вывести 6843.

import random
import timeit
import cProfile

#Решение 1. (базовый из залания №3 к уроку №2)
def revers_1(a, b):
    while a != 0:
        b = a % 10 + b * 10
        a = a//10
        revers_1(a, b)
    return b

revers_1(123,0)

# Решение 2. (вариант без рекурсии)
def revers_2(a, b):
    while a > 0:
        b = b*10 + a%10
        a = a//10
    return(b)

revers_2(123, 0)

# Решение 3. (фантазия начала заканчиваться, перекрутил немного решение 2 - увеличил количество итераций)
def revers_3(a, b):
    while a > 0:
        rest = a % 10
        a = a // 10
        b = b * 10
        b = b + rest
    return (b)

revers_3(123, 0)


MIN_ITEM = 1000000
MAX_ITEM = 10000000

x = random.randint(MIN_ITEM, MAX_ITEM)
y = 0
repeat = 10000

t1 = timeit.timeit(f'revers_1({x}, {y})', number = repeat, globals = globals()) #Замеры: n = 10 (0.0003147000000000011); n = 100 (0.0042483000000000035); n = 10000 (0.3203376)
t2 = timeit.timeit(f'revers_2({x}, {y})', number = repeat, globals = globals()) #Замеры: n = 10  (1.1600000000000499e-05); n = 100 (0.00010200000000000486); n = 10000 (0.009735500000000008)
t3 = timeit.timeit(f'revers_3({x}, {y})', number = repeat, globals = globals()) #Замеры: n = 10 (1.2399999999999217e-05); n = 100 (0.00010820000000000274); n = 10000 (0.0104321)

# cProfile.run(f'revers_1({x}, {y})')
# cProfile.run(f'revers_2({x}, {y})')
# cProfile.run(f'revers_3({x}, {y})')

print('\nВремя выполнения решения №1: {}\nВремя выполнения решения №2: {}\nВремя выполнения решения №3: {}'.format(t1, t2, t3))

print('\nРешение №2 быстрее решения №1 в {} раз(а)'.format(round(t1/t2)))


#Вывод:

# Самым "быстрым" решением является вариант №2.
# Самым "медленным" является вариант решения №1, в котором применяется рекурсия.
# Вариант решнения №3 (аналог решения №2, но с больщим количеством итераций) оказался чуть медленнее решения №2, но быстрее решения №1 с рекурсией.

# Я ожидал, что рекурсия отработает быстрее, но почему-то вышло наоборот.
# Наверное, причина кроется в оптимизации хвостовой рекурсии в Python - то ли ее нет, то ли она реализована не очень правильно.
# Получается, что в данном случае "плоская" реализация алгоритма является более оптимальной, чем его рекурсивный вариант.


